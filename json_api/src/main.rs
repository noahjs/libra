#![feature(proc_macro_hygiene, decl_macro)]

#[macro_use]
extern crate rocket;
extern crate structopt;
#[macro_use]
extern crate serde_derive;

use parking_lot::Mutex;

use client::client_proxy::ClientProxy;
use logger::set_default_global_logger;
use structopt::StructOpt;

use crate::handlers::AppState;

mod error;
mod handlers;
mod serializers;

#[derive(Debug, StructOpt)]
#[structopt(
    name = "Libra JSON API",
    author = "The Libra Association",
    about = "Libra client over JSON API"
)]
struct Args {
    /// Admission Control port to connect to.
    #[structopt(short = "p", long = "port", default_value = "30307")]
    pub port: String,
    /// Host address/name to connect to.
    #[structopt(short = "a", long = "host")]
    pub host: String,
    /// Path to the generated keypair for the faucet account. The faucet account can be used to
    /// mint coins. If not passed, a new keypair will be generated for
    /// you and placed in a temporary directory.
    /// To manually generate a keypair, use generate_keypair:
    /// `cargo run -p generate_keypair -- -o <output_file_path>`
    #[structopt(short = "m", long = "faucet_key_file_path")]
    pub faucet_account_file: Option<String>,
    /// Host that operates a faucet service
    /// If not passed, will be derived from host parameter
    #[structopt(short = "f", long = "faucet_server")]
    pub faucet_server: Option<String>,
    /// File location from which to load mnemonic word for user account address/key generation.
    /// If not passed, a new mnemonic file will be generated by libra_wallet in the current
    /// directory.
    #[structopt(short = "n", long = "mnemonic_file")]
    pub mnemonic_file: Option<String>,
    /// File location from which to load config of trusted validators. It is used to verify
    /// validator signatures in validator query response. The file should at least include public
    /// key of all validators trusted by the client - which should typically be all validators on
    /// the network. To connect to testnet, use 'libra/scripts/cli/trusted_peers.config.toml'.
    /// Can be generated by libra-config for local testing:
    /// `cargo run --bin libra-config`
    /// But the preferred method is to simply use libra-swarm to run local networks
    #[structopt(short = "s", long = "validator_set_file")]
    pub validator_set_file: String,
    /// If set, client will sync with validator during wallet recovery.
    #[structopt(short = "r", long = "sync")]
    pub sync: bool,
}

fn main() -> std::io::Result<()> {
    let _logger = set_default_global_logger(false /* async */, None);
    crash_handler::setup_panic_handler();

    let args = Args::from_args();
    let faucet_account_file = args.faucet_account_file.unwrap_or_else(|| "".to_string());

    let client_proxy = ClientProxy::new(
        &args.host,
        &args.port,
        &args.validator_set_file,
        &faucet_account_file,
        args.sync,
        args.faucet_server,
        args.mnemonic_file,
    )
    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, &format!("{}", e)[..]))?;

    // Test connection to validator
    let test_ret = client_proxy.test_validator_connection();

    if let Err(e) = test_ret {
        println!(
            "Not able to connect to validator at {}:{}, error {:?}",
            args.host, args.port, e
        );
        return Ok(());
    }

    rocket::ignite()
        .manage(Mutex::new(AppState {
            proxy: client_proxy,
        }))
        .mount(
            "/",
            routes![
                handlers::create_next_account,
                handlers::get_latest_account_state,
                handlers::mint_coins,
                handlers::transfer_coins,
                handlers::get_committed_txn_by_acc_seq,
                handlers::get_committed_txn_by_range,
                handlers::get_events_by_account_and_type,
            ],
        )
        .launch();

    Ok(())
}
